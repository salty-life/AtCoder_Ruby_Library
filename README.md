# AtCoder_Ruby_Library

AtCoderで使うライブラリをRubyで実装したものです。
最適化などはほとんど行っていないため、TLEになる可能性があります。

コメントもほとんどないため、自分以外にはわかりにくいと思います。

以下、各ファイルの説明

## binary_search.rb

昇順に並んだ配列の中から、検索対象となる要素を2分探索で探し出し、そのインデックスを返します。
配列の各要素、および検索要素は比較可能である必要があります。

upper_boundは検索対象を超える要素のうち、最小のインデックスを返し、lower_boundは検索対象以上である最小のインデックスを返します。
ただし、配列の末尾の要素より検索対象が大きい（upperの場合は以上）ときは、配列のサイズを返します。

```ruby
a=(1..4).to_a
p a
for i in 1..(2*a.length+1) do
    p [i/2.0,lower_bound(a,i/2.0),upper_bound(a,i/2.0)]
end
#=>
# [1, 2, 3, 4]
# [0.5, 0, 0]
# [1.0, 0, 1]
# [1.5, 1, 1]
# [2.0, 1, 2]
# [2.5, 2, 2]
# [3.0, 2, 3]
# [3.5, 3, 3]
# [4.0, 3, 4]
# [4.5, 4, 4]
```


## bit.rb
Binary Indexed Treeの実装。
変更の範囲、クエリの範囲を基に３種類のパターンを実装した。
いずれもクエリの処理に$O(\log N)$かかる。
（変更：一点、クエリ：一点は通常の配列で実装可）

さらに、数字をカウントし、k番目の要素は何であるかを返すBITも実装。

### PRBIT
変更：一点、クエリ：範囲の場合の実装。
### RPBIT
変更：範囲、クエリ：一点の場合の実装。
### RRBIT
変更：範囲、クエリ：範囲の場合の実装。
### CounterBIT
変更：要素の追加・削除、クエリ：k番目の要素の場合の実装。

## segmenttree.rb
Segment Treeの実装。
変更が一点であるか範囲であるかの２パターン作成した。
いずれも変更・クエリの処理に$O(\log N)$かかる。

### SegmentTree
変更が一点である場合のSegmentTree。
### LazySegmentTree
変更が範囲である場合のSegmentTree。遅延評価を行うことで、オーダーを減らしている。
